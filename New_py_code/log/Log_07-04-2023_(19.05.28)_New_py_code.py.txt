
  _                   ______ _ _      
 | |                 |  ____(_) |     
 | |     ___   __ _  | |__   _| | ___ 
 | |    / _ \ / _` | |  __| | | |/ _ \
 | |___| (_) | (_| | | |    | | |  __/
 |______\___/ \__, | |_|    |_|_|\___|
               __/ |                  
              |___/                   
--------------------------------------
start:            07-04-2023_19:05:28
file:             New_py_code.py
OS:               Windows
User:             Napo_II
--------------------------------------
logNow:
07-04-2023_19:05:28 --> __function should not be executed when the file is imported as a module.
This was not the case!
07-04-2023_19:05:31 --> Config loaded: [ folder = E:/Pr0grame/My_ Pyhton/work_in_progress ]
07-04-2023_19:05:32 --> Config loaded: [ github_user = NapoII ]
07-04-2023_19:05:32 --> The folder [111] was created in the directory:
  ->   E:/Pr0grame/My_ Pyhton/work_in_progress\111
07-04-2023_19:05:32 --> The folder [111] was created in the directory:
  ->   E:\Pr0grame\My_ Pyhton\work_in_progress\111\111
07-04-2023_19:05:32 --> The folder [README_img] was created in the directory:
  ->   E:\Pr0grame\My_ Pyhton\work_in_progress\111\README_img
07-04-2023_19:05:32 --> The folder [test] was created in the directory:
  ->   E:\Pr0grame\My_ Pyhton\work_in_progress\111\test
07-04-2023_19:05:32 --> The folder [util] was created in the directory:
  ->   E:\Pr0grame\My_ Pyhton\work_in_progress\111\111\util
07-04-2023_19:05:32 --> 
file [__init__.py] is created...with conetnt:\"""Full Doku on: https://github.com/NapoII/111"
-----------------------------------------------
!!! ADD MUST HAVE INFO !!
------------------------------------------------
"""

__version__ = "0.1.0"
__author__ = "NapoII"
07-04-2023_19:05:32 --> 
file [__funktion__.py] is created...with conetnt:\"""
Use: - from util.__funktion__ import *

ChatGPT promt for docstrgs:

write me a .py docstr ("""""") with the content:
Args, Returns, Example Usage for the code in eng.
Use for Args and Returns "- " for a listing and for Example Usage: ">>> ".
Here is the code:

"""

import logNow
from logNow import log
import os
from configparser import ConfigParser
import shutil
import time

if __name__ == "__funktion__":
    log("__function should not be executed when the file is imported as a module.\nThis was not the case!", "r")
else:
    pass

def read_config(config_dir, section, option):
    """Reads a specific option from a config file in a specific section.

    Args:
    - config_dir (str): The path of the config file.
    - section (str): The section where the searched option is located.
    - option (str): The name of the option being searched for.

    Returns:
    - str: The value of the searched option.

    Example Usage:
        Assuming you have a config file named 'example_config.ini' that looks like this:

        - [database]
        - host = localhost
        - port = 5432
        - username = dbuser
        - password = dbpass

        You can use the function to read the value of the 'host' option in the 'database' section like this:

        >>> read_config('example_config.ini', 'database', 'host')
        'localhost'
    """

    config = ConfigParser()
    config.read(config_dir)
    load_config = (config[section][option])

    log("Config loaded: [ "+(option) + " = " + (load_config)+" ]", "g")

    return load_config


def write_config(config_dir, section, Key, option):
    """
Args:
    - config_dir (str): The directory where the configuration file is located.
    - section (str): The section name in the configuration file.
    - Key (str): The key to update or add in the specified section.
    - option (str): The value to assign to the specified key.

Returns:
    - None

Example Usage:
    - Updating an existing key in a section of a configuration file
    >>>  write_config('config.ini', 'section1', 'key1', 'new_value')

    >>>  Adding a new key in a section of a configuration file
    >>>  write_config('config.ini', 'section2', 'key2', 'value2')
"""
    config = ConfigParser()
    # update existing value
    config.read(config_dir)
    try:
        config.add_section(section)
    except:
        pass
    config.set(section, Key,option) #Updating existing entry 
    with open(config_dir, 'w') as configfile:
        config.write(configfile)
    print (f"\nChange settings -> {config_dir}\n[{section}]\n{Key}) = {option}\n")



def Folder_gen(Folder_Name, Folder_dir):
    """Creates a new folder if it does not already exist.

            Args:
            - folder_name (str): The name of the folder to be created.
            - folder_dir (str): The directory in which the folder is to be created.

            Returns:
            - str: The full path of the created folder.

            Example usage :
            >>> Folder_Name = "my_folder"
            >>> Folder_dir = "path/to/parent/directory"
            >>> created_folder_path = Folder_gen(Folder_Name, Folder_dir)
            >>> print("Created folder path:", created_folder_path)
    """

    print("Folder structure is checked and created if necessary...\n")
    folder = Folder_Name
    # Specifies desired file path
    #dir = "~/"+str(Folder_dir)+"/"+str(folder)
    full_path = Folder_dir + os.path.sep + Folder_Name
    # Adds file path with PC user name
    #full_path = os.path.expanduser(dir)
    # Checks file path for exsistance Ture/False
    if os.path.exists(full_path):
        print("Folder structure already exists")
        print("  ->   " + str(full_path))
    else:                                               # Creates folder if not available
        os.makedirs(full_path)
        log(f"The folder [{folder}] was created in the directory:\n  ->   {full_path}", "b")
        print("\n")
    return(os.path.normpath(full_path))


def Create_File(File_name, save_path, Inhalt):
    """Creates a new text file if it does not already exist and fills it with the specified content.

    Args:
    - File_name (str): The name of the text file.
    - save_path (str): The path where the text file should be saved.
    - Content (str): The content to be written to the text file.

    Returns:
    - str: The complete path of the created text file.

    Example usage:
    >>> file_name = "my_text_file.txt"
    >>> save_path = "/path/to/save/directory"
    >>> content = "This is the content of my text file."
    >>> created_file_path = Create_File(file_name, save_path, content)
    >>> print(created_file_path)
    '/path/to/save/directory/my_text_file.txt'
    """

    complete_Path_Text = save_path + os.path.sep + File_name
    if os.path.exists(complete_Path_Text):
        return complete_Path_Text
    else:
        # Create file
        file1 = open(complete_Path_Text, "w", encoding='utf-8')
        # toFile = input("Write what you want into the field")                   # File input def.
        # File is filled with input
        file1.write(f"{Inhalt}")
        file1.close()
        log(f"\nfile [{File_name}] is created...with conetnt:\{Inhalt}","b")
        return complete_Path_Text


def Read_File_Out(dir):
    """
    Reads the contents of a file located at the given directory path and returns it as a string.

    Args:
    - dir (str): The directory path of the file to be read.

    Returns:
    - content (str): The contents of the file as a string.

    Example usage:
    >>> file_path = "/path/to/file.txt"
    >>> content = Read_File_Out(file_path)
    >>> print(content)
    'This is the content of the file.'
    """
    with open(dir, 'r', encoding='utf-8') as f:
        content = f.read()

    return content


def copy_image(source_file, dest_file) -> None:
    """Copies an image file from the source path to the destination path.

    Args:
    - source_file (str): The path of the image file to be copied.
    - dest_file (str): The path where the image file should be copied to.

    Returns:
    - file (str) full path of the img

    Raises:
    - IOError: If an error occurs while copying the file.
    
    Example usage:
    >>> source_path = "/path/to/source/image.jpg"
    >>> dest_path = "/path/to/destination/image.jpg"
    >>> copy_image(source_path, dest_path)
    '/path/to/destination/image.jpg'
    """
    try:
        shutil.copy(source_file, dest_file)
        file = dest_file
        log(f"Image [{file}] successfully copied!", "b")
        return file
    except IOError as e:
        log(f"Error when copying the file: {e}", "r")


def File_name_with_time(FileName):
    """Generate a filename with a timestamp.

    Args:
    - FileName (str): The name of the file.

    Returns:
    - FullName (str): The full name of the file with a timestamp in the format of "FileName-DD_MM_YYYY-HH.MM".

    Example usage:
    >>> Datei_name_mit_Zeit("report")
    'report-04_04_2023-15.30'
    """
    Date = Date_Time=(time.strftime("%d_%m-%Y-%H.%M"))        # Generates date formater
    FullName = (FileName+"-"+(Date))                           # Generates file name
    return FullName


def TimeStemp():
    """
    Generates a timestamp string in the format of "dd_mm-yyyy_HH:MM:SS".

    Args:
        None

    Returns:
        A string representing the current date and time in the format "dd_mm-yyyy_HH:MM:SS".

    Example Usage:
        >>> TimeStemp()
        '04_04-2023_11:22:33'
    """
    TimeStemp = Date_Time=(time.strftime("%d_%m-%Y_%H:%M:%S"))
    return TimeStemp

################################################################################################################################
#def spez.

07-04-2023_19:05:32 --> The folder [cfg] was created in the directory:
  ->   E:\Pr0grame\My_ Pyhton\work_in_progress\111\111\cfg
07-04-2023_19:05:32 --> 
file [config.ini] is created...with conetnt:\"""
Use: - from util.__funktion__ import *

ChatGPT promt for docstrgs:

write me a .py docstr ("""""") with the content:
Args, Returns, Example Usage for the code in eng.
Use for Args and Returns "- " for a listing and for Example Usage: ">>> ".
Here is the code:

"""

import logNow
from logNow import log
import os
from configparser import ConfigParser
import shutil
import time

if __name__ == "__funktion__":
    log("__function should not be executed when the file is imported as a module.\nThis was not the case!", "r")
else:
    pass

def read_config(config_dir, section, option):
    """Reads a specific option from a config file in a specific section.

    Args:
    - config_dir (str): The path of the config file.
    - section (str): The section where the searched option is located.
    - option (str): The name of the option being searched for.

    Returns:
    - str: The value of the searched option.

    Example Usage:
        Assuming you have a config file named 'example_config.ini' that looks like this:

        - [database]
        - host = localhost
        - port = 5432
        - username = dbuser
        - password = dbpass

        You can use the function to read the value of the 'host' option in the 'database' section like this:

        >>> read_config('example_config.ini', 'database', 'host')
        'localhost'
    """

    config = ConfigParser()
    config.read(config_dir)
    load_config = (config[section][option])

    log("Config loaded: [ "+(option) + " = " + (load_config)+" ]", "g")

    return load_config


def write_config(config_dir, section, Key, option):
    """
Args:
    - config_dir (str): The directory where the configuration file is located.
    - section (str): The section name in the configuration file.
    - Key (str): The key to update or add in the specified section.
    - option (str): The value to assign to the specified key.

Returns:
    - None

Example Usage:
    - Updating an existing key in a section of a configuration file
    >>>  write_config('config.ini', 'section1', 'key1', 'new_value')

    >>>  Adding a new key in a section of a configuration file
    >>>  write_config('config.ini', 'section2', 'key2', 'value2')
"""
    config = ConfigParser()
    # update existing value
    config.read(config_dir)
    try:
        config.add_section(section)
    except:
        pass
    config.set(section, Key,option) #Updating existing entry 
    with open(config_dir, 'w') as configfile:
        config.write(configfile)
    print (f"\nChange settings -> {config_dir}\n[{section}]\n{Key}) = {option}\n")



def Folder_gen(Folder_Name, Folder_dir):
    """Creates a new folder if it does not already exist.

            Args:
            - folder_name (str): The name of the folder to be created.
            - folder_dir (str): The directory in which the folder is to be created.

            Returns:
            - str: The full path of the created folder.

            Example usage :
            >>> Folder_Name = "my_folder"
            >>> Folder_dir = "path/to/parent/directory"
            >>> created_folder_path = Folder_gen(Folder_Name, Folder_dir)
            >>> print("Created folder path:", created_folder_path)
    """

    print("Folder structure is checked and created if necessary...\n")
    folder = Folder_Name
    # Specifies desired file path
    #dir = "~/"+str(Folder_dir)+"/"+str(folder)
    full_path = Folder_dir + os.path.sep + Folder_Name
    # Adds file path with PC user name
    #full_path = os.path.expanduser(dir)
    # Checks file path for exsistance Ture/False
    if os.path.exists(full_path):
        print("Folder structure already exists")
        print("  ->   " + str(full_path))
    else:                                               # Creates folder if not available
        os.makedirs(full_path)
        log(f"The folder [{folder}] was created in the directory:\n  ->   {full_path}", "b")
        print("\n")
    return(os.path.normpath(full_path))


def Create_File(File_name, save_path, Inhalt):
    """Creates a new text file if it does not already exist and fills it with the specified content.

    Args:
    - File_name (str): The name of the text file.
    - save_path (str): The path where the text file should be saved.
    - Content (str): The content to be written to the text file.

    Returns:
    - str: The complete path of the created text file.

    Example usage:
    >>> file_name = "my_text_file.txt"
    >>> save_path = "/path/to/save/directory"
    >>> content = "This is the content of my text file."
    >>> created_file_path = Create_File(file_name, save_path, content)
    >>> print(created_file_path)
    '/path/to/save/directory/my_text_file.txt'
    """

    complete_Path_Text = save_path + os.path.sep + File_name
    if os.path.exists(complete_Path_Text):
        return complete_Path_Text
    else:
        # Create file
        file1 = open(complete_Path_Text, "w", encoding='utf-8')
        # toFile = input("Write what you want into the field")                   # File input def.
        # File is filled with input
        file1.write(f"{Inhalt}")
        file1.close()
        log(f"\nfile [{File_name}] is created...with conetnt:\{Inhalt}","b")
        return complete_Path_Text


def Read_File_Out(dir):
    """
    Reads the contents of a file located at the given directory path and returns it as a string.

    Args:
    - dir (str): The directory path of the file to be read.

    Returns:
    - content (str): The contents of the file as a string.

    Example usage:
    >>> file_path = "/path/to/file.txt"
    >>> content = Read_File_Out(file_path)
    >>> print(content)
    'This is the content of the file.'
    """
    with open(dir, 'r', encoding='utf-8') as f:
        content = f.read()

    return content


def copy_image(source_file, dest_file) -> None:
    """Copies an image file from the source path to the destination path.

    Args:
    - source_file (str): The path of the image file to be copied.
    - dest_file (str): The path where the image file should be copied to.

    Returns:
    - file (str) full path of the img

    Raises:
    - IOError: If an error occurs while copying the file.
    
    Example usage:
    >>> source_path = "/path/to/source/image.jpg"
    >>> dest_path = "/path/to/destination/image.jpg"
    >>> copy_image(source_path, dest_path)
    '/path/to/destination/image.jpg'
    """
    try:
        shutil.copy(source_file, dest_file)
        file = dest_file
        log(f"Image [{file}] successfully copied!", "b")
        return file
    except IOError as e:
        log(f"Error when copying the file: {e}", "r")


def File_name_with_time(FileName):
    """Generate a filename with a timestamp.

    Args:
    - FileName (str): The name of the file.

    Returns:
    - FullName (str): The full name of the file with a timestamp in the format of "FileName-DD_MM_YYYY-HH.MM".

    Example usage:
    >>> Datei_name_mit_Zeit("report")
    'report-04_04_2023-15.30'
    """
    Date = Date_Time=(time.strftime("%d_%m-%Y-%H.%M"))        # Generates date formater
    FullName = (FileName+"-"+(Date))                           # Generates file name
    return FullName


def TimeStemp():
    """
    Generates a timestamp string in the format of "dd_mm-yyyy_HH:MM:SS".

    Args:
        None

    Returns:
        A string representing the current date and time in the format "dd_mm-yyyy_HH:MM:SS".

    Example Usage:
        >>> TimeStemp()
        '04_04-2023_11:22:33'
    """
    TimeStemp = Date_Time=(time.strftime("%d_%m-%Y_%H:%M:%S"))
    return TimeStemp

################################################################################################################################
#def spez.

07-04-2023_19:05:32 --> 
file [111.py] is created...with conetnt:\"""Full Doku on: https://github.com/NapoII/111"
-----------------------------------------------
!!! ADD MUST HAVE INFO !!
------------------------------------------------
"""

#imports
import os
import sys

from util.__funktion__ import *

# 111.py
log(f'Programme has been started!','green')

07-04-2023_19:05:32 --> 
file [.gitignore] is created...with conetnt:\.111.egg-info
.build
.dist
07-04-2023_19:05:32 --> 
file [requirements.txt] is created...with conetnt:\logNow
configparser

07-04-2023_19:05:32 --> 
file [TODO.md] is created...with conetnt:\### TODO

---

#### Basic
- [x] New project generated with `[New_py_Code]`
- [ ] Initialise a new Git with Git Bash:
    ```Git Bash
    git init
    git add.
    git commit -"Hello world"
    ```
- [ ] Create a new repository on gitHub: https://github.com/new
- [ ] Add the desired licence, for example: `MIT License` 

- [ ] Create remote access to the repository with Git Bash and push the project to GitHub.
    ```Git Bash
    git remote o https://github.com/<GitHub User name>/<repository name>
    git push o main
    ```
- [ ] ☕ Now that the base is in place Treat yourself to a cup of tea.

---
#### Start

- [ ] Start your coding
- [ ] end big step with a git commit. Add files/folders previously locked to Git to the `.gitignore` as needed. 
    ```Git Bash
    git add .
    git commit "<text>"
    git push o main
    ```
- [ ] ☕ Now that the first code is up, take some time for Tea again and write down your next steps here in the TODO file.
- [ ] 

#### The Finish

- [ ] Run the code for the final test
- [ ] If the code does what it is supposed to do, do another push into git and go into finishing.
    ```Git Bash
    git add .
    git commit "Finel Test is over!"
    git push o main
    ```
- [ ] Delete all folders and files you no longer need.
- [ ] If necessary, change `log("str)` to `print("str")` or delete the `print()` directly.
- [ ] Check your code and files for missing dokus. *ChatGPT kann dir die arbeit abnehmen use: 
    ```ChatGPT promt:
        write me a .py docstr ("""""") with the content: 
        Args, Returns, Example Usage for the code in eng.
        Use for Args and Returns "- " for a listing and for Example Usage: ">>> ".
        Here is the code: <your code Snippet>
        ```
- [ ] If you have used another language translate the code into english.
- [ ] Complete the `requirements.txt` list.
- [ ] Delete all private data from the config file.
- [ ] ☕ Have a Tea and think about the content of the ReadMe.
- [ ] Write the readme.
- [ ] check the `setup.py` if it still exists.
- [ ] check the `.gitignor` file.
- [ ] Final git Push:
    ```Git Bash
        git add .
        git commit "Touchdown! "
        git push o main
        ```
- [ ] Upload to pypi if desired : *nice guide for pypi publishing https://betterscientificsoftware.github.io/python-for-hpc/tutorials/python-pypi-packaging/*

- [ ] ☕ Your are DONE! ONE LAST TEA.

### Bugs

- [ ]

---

### Ideas

- [ ]

07-04-2023_19:05:32 --> 
file [test.py] is created...with conetnt:\from util.__funktion__ import *
07-04-2023_19:05:32 --> Config loaded: [ github_user = NapoII ]
07-04-2023_19:05:32 --> Config loaded: [ discord_link = https://discord.gg/knTKtKVfnr ]
07-04-2023_19:05:32 --> Config loaded: [ discord_ID = 190307701169979393 ]
07-04-2023_19:05:33 --> Image [E:\Pr0grame\My_ Pyhton\work_in_progress\111\README_img] successfully copied!
07-04-2023_19:05:33 --> 
file [README.md] is created...with conetnt:\[![github/NapoII](https://raw.githubusercontent.com/NapoII/111/main/README_img/Readme_top.png)](https://github.com/NapoII)

# 111

[![downloads/total](https://img.shields.io/github/downloads/NapoII/111/total)](https://github.com/NapoII/111/archive/refs/heads/main.zip) [![github/repo-size](https://img.shields.io/github/repo-size/NapoII/111)](https://github.com/NapoII/111/archive/refs/heads/main.zip) [![github/license](https://img.shields.io/github/license/NapoII/111)](https://github.com/NapoII/111/blob/main/LICENSE) [![github/last-commit](https://img.shields.io/github/downloads/NapoII/111/total)](https://img.shields.io/github/issues/NapoII/111?style=plastic) [![github/issues_open](https://img.shields.io/github/issues/NapoII/111?style=plastic)](https://img.shields.io/github/issues-raw/NapoII/111) [![github/stars](https://img.shields.io/github/stars/NapoII/111?style=social)](https://github.com/NapoII/111/stargazers) [![discord](https://img.shields.io/discord/190307701169979393)](https://discord.gg/knTKtKVfnr)

Coming soon...
## 📝 Table of Contents
+ [Demo / Working](#demo)
+ [Install](#usage)
+ [How it works](#Use)
+ [Lizenz](#Lizenz)
## 🎥 Demo / Working <a name = "demo"></a>
coming soon...

## 💻 Install <a name = "usage"></a>
```cmd
git clone https://github.com/NapoII/111
pip install -r requirements.txt
```
## 💭 How it works <a name = "Use"></a>

start 111.py directly from the folder or run in cmd:
```cmd
cd <local path of 111>
python 111.py
```

## 📚 Lizenz <a name = "Lizenz"></a>
MIT License

Copyright (c) 2023 NapoII
<small><small><small>
Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE
    
<p align="center">
<img src="https://raw.githubusercontent.com/NapoII/NapoII/233630a814f7979f575c7f764dbf1f4804b05332/Bottom.svg" alt="Github Stats" />
</p>

07-04-2023_19:05:33 --> 
file [setup.py] is created...with conetnt:\from setuptools import setup, find_packages

with open("README.md") as readme_file:
    readme = readme_file.read()

setup(
    name='111',
    version='0.1.0',    
    description="!!! add short description !!!",
    long_description = readme,
    long_description_content_type="text/markdown",
    url='https://github.com/NapoII/111',
    author='NapoII',
    author_email='!!! add mail !!!',
    license='MIT License',
    packages="!!! add content from requirements.txt !!!",
    install_requires= [],

    classifiers=[
    !!! add classifiers !!!
        ],)
07-04-2023_19:05:34 --> The project was created and the folder address was added to the clipboard..
